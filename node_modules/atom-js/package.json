{
  "name": "atom-js",
  "version": "0.5.6",
  "description": "Small JS class that provides async control flow, property listeners, barrier pattern, and more.",
  "author": {
    "name": "Chris Campbell",
    "email": "ccampbell@zynga.com",
    "url": "https://github.com/quaelin"
  },
  "homepage": "https://github.com/zynga/atom",
  "bugs": {
    "url": "https://github.com/zynga/atom/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/zynga/atom.git"
  },
  "main": "./atom.js",
  "scripts": {
    "test": "node test.js"
  },
  "license": "BSD",
  "readme": "Overview\n========\n\nAtom.js is a small, easy to use JavaScript class that provides asynchronous\ncontrol flow, event/property listeners, barriers, and more.\n\n\nFeatures\n========\n\n - Small: 3.4kB minified, 1.5kB gzipped.\n - No dependencies: works in a browser, or in node.\n - Enables programming patterns that reduce the need for deeply nested\n   callbacks and conditionals.\n\n\nInstall\n=======\n\n\tnpm install atom-js\n\n\nUnit Tests\n==========\n\nTo run from command line using node.js:\n\n\tnode test.js      // brief\n\tnode test.js -v   // verbose\n\nTo run in a browser, open `test.html`, or go \n[here](http://zynga.github.io/atom/test.html).\n\n\nTutorial\n========\n\nThis is `a`.\n\n```javascript\n\tvar a\n```\n\n`a` is an atom.\n\n```javascript\n\tvar a = atom();\n```\n\n\n### Properties\n\nAn atom has properties.  The `.get()` and `.set()` methods may be employed to\nread and write values of any type.\n\n```javascript\n\ta.set('key', 'value');\n\tconsole.log('Value of key: ' + a.get('key'));\n\n\ta.set({\n\t\tpi: 3.141592653,\n\t\tr: 5,\n\t\tcircumference: function () {\n\t\t\treturn 2 * a.get('pi') * a.get('r');\n\t\t}\n\t});\n\tconsole.log('Circumference: ' + a.get('circumference')());\n```\n\nParameters to the constructor will also be set as properties.\n\n```javascript\n\ta = atom('key', 'value');\n\n\ta = atom({ pi: 3.141592653, r: 5 });\n```\n\nUse `.has()` to query for existence of a property, and `.keys()` to get a list\nof all properties that have been set.\n\n```javascript\n\tif (a.has('game')) {\n\t\tconsole.log('What \"a\" brings to the table: ' + a.keys());\n\t}\n```\n\nThe `.each()` method lets you execute a function on a series of properties.\n\n```javascript\n\ta.set({ r: 0xBA, g: 0xDA, b: 0x55 });\n\ta.each(['r', 'g', 'b'], function (key, value) {\n\t\tconsole.log(key + ': ' + value);\n\t});\n```\n\n\n### Listeners\n\nListeners may be attached to atoms in a variety of ways.\n\nTo be notified as soon as a property is set, use the `.once()` method.  The\ncallback will be called immediately if the property is already set.\n\n```javascript\n\ta.once('userInfo', function (userInfo) {\n\t\talert('Welcome, ' + userInfo.name + '!');\n\t});\n```\n\nMany atom methods can work with more than one property at a time.\n\n```javascript\n\ta.once(['userInfo', 'appInfo'], function (user, app) {\n\t\talert('Welcome to ' + app.name + ', ' + user.name + '!');\n\t});\n```\n\nWhen you just want to know about the next change, even if the property is\nalready set, use `.next()`.\n\n```javascript\n\ta.next('click', function (click) {\n\t\talert('Are you done clicking on ' + click.button + ' yet?');\n\t});\n```\n\nTo watch for any future changes to a property, use the `.on()` (alias `.bind()`)\nmethod.\n\n```javascript\n\tfunction myErrorHandler(error) {\n\t\tconsole.log('There was a grevious calamity of code in ' + a.get('module'));\n\t\tconsole.log(error);\n\t}\n\ta.on('error', myErrorHandler);\n```\n\nNote that setting a property with a primitive (string/number/boolean) value will\nonly trigger listeners if the value is *different*.  On the other hand, setting\nan array or object value will *always* trigger listeners.\n\nYou can unregister any listener using `.off()` (alias `.unbind()`).\n\n```javascript\n\ta.off(myErrorHandler);\n```\n\nIf you only want to remove the listener associated with a particular key or\nkeys, you can specify those too:\n\n```javascript\n\ta.off(['a', b'], myErrorHandler);\n```\n\n\n### Needs and Providers\n\nYou can register a provider for a property.\n\n```javascript\n\ta.provide('privacyPolicy', function (done) {\n\t\thttpRequest(baseUrl + '/privacy.txt', function (content) {\n\t\t\tdone(content);\n\t\t});\n\t});\n```\n\nProviders only get invoked if there is a need, and if the property is not\nalready set.  Use the `.need()` method to declare a need for a particular\nproperty.  If a corresponding provider is registered, it will be invoked.\nOtherwise, `.need()` behaves just like `.once()`.\n\n```javascript\n\ta.on('clickPrivacy', function () {\n\t\ta.need('privacyPolicy', function (text) {\n\t\t\telement.innerText = text;\n\t\t});\n\t});\n```\n\n\n### Entanglement\n\nProperties of two or more atoms can be entangled, using the `.entangle()`\nmethod.  When an entangled property gets set on one atom, the value will\ninstantly propagate to the other.\n\n```javascript\n\tvar b = atom();\n\ta.entangle(b, 'email');\n\ta.set('email', 'someone@example.com');\n\tconsole.log('Entangled email: ' + b.get('email'));\n```\n\n`.entangle()` also works when called with a list of properties.\n\n```javascript\n\ta.entangle(b, ['firstname', 'lastname']);\n```\n\nIf called with a map of property names, then property 'X' on one atom can be\nentangled with property 'Y' on the other atom.\n\n```javascript\n\ta.entangle(b, { firstname: 'first', lastname: 'last' });\n\ta.set('firstname', 'Joe');\n\tconsole.log('Welcome, ' + b.get('first'));\n```\n\nNote that entangled properties are not actually synchronized until the first\nchange *after* entanglement.\n\n\n### Asynchronous Queueing\n\nString together a series of asynchronous functions using the `.chain()` method.\n\n```javascript\n\ta.chain(\n\t\tfunction (nextLink) {\n\t\t\tcallAjaxMethod('callThisFirst', function (firstResult) {\n\t\t\t\tnextLink(firstResult);\n\t\t\t});\n\t\t},\n\t\tfunction (nextLink, firstResult) {\n\t\t\tcallAjaxMethod('callThisSecond', function (secondResult) {\n\t\t\t\tnextLink(secondResult);\n\t\t\t});\n\t\t}\n\t);\n```\n\n\n### Method Chaining\n\nNot to be confused with the `.chain()` method specifically, \"method chaining\"\nactually refers to the practice of stringing together multiple method calls in\na single expression.\n\n```javascript\n\ta = atom('start', new Date())\n\t\t.once('loaded', function () {\n\t\t\tconsole.log('Finished loading.');\n\t\t})\n\t\t.once('shutdown', function () {\n\t\t\tconsole.log('Shutting down.');\n\t\t})\n\t\t.set('loaded', true);\n```\n\nThe `.chain()`, `.each()`, `.entangle()`, `.mixin()`, `.need()`, `.next()`,\n`.off()`, `.on()`, `.once()`, `.provide()` and `.set()` methods are all\nchainable.\n\n\n### Cleanup\n\nRelease references to all data and callback functions with the `.destroy()`\nmethod.\n\n```javascript\n\ta.destroy();\n```\n\n\nAdditional Resources\n====================\n\n - [Blog post: Barriers with Atom](http://christophercampbell.wordpress.com/2013/01/01/barriers-with-atom/)\n - [Blog post: Serial and Parallel Tasks with Atom](http://christophercampbell.wordpress.com/2013/01/01/serial-and-parallel-tasks-with-atom/)\n - [Blog post: Providers with Atom](http://christophercampbell.wordpress.com/2013/01/01/providers-with-atom/)\n",
  "readmeFilename": "README.md",
  "_id": "atom-js@0.5.6",
  "dist": {
    "shasum": "6ff2a8a29b63da1804db93ec64dafba7fce158a6"
  },
  "_from": "atom-js@",
  "_resolved": "https://registry.npmjs.org/atom-js/-/atom-js-0.5.6.tgz"
}
